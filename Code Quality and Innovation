1. Modular & Layered Architecture
We use a 3-layer structure:
Model Layer: Campaign, User
DAO Layer: CampaignDAO, UserDAO
Controller Layer: DashboardController, CreateCampaignController, etc.
Example:
CampaignDAO.java cleanly separates DB logic from UI:
public List<Campaign> getAllCampaigns() {
    List<Campaign> list = new ArrayList<>();
    String sql = "SELECT * FROM campaigns";

    try (Connection con = DBConnect.getConnection();
         PreparedStatement ps = con.prepareStatement(sql);
         ResultSet rs = ps.executeQuery()) {

        while (rs.next()) {
            list.add(new Campaign(
                rs.getInt("id"),
                rs.getString("title"),
                rs.getDouble("goal"),
                rs.getDouble("raised"),
                rs.getString("description")
            ));
        }
    }
    return list;
}
This keeps database code out of the controllers ‚Üí improves maintainability.


2. Clean MVC (FXML + JavaFX Controllers)
Your UI files such as dashboard.fxml, createCampaign.fxml, and viewCampaigns.fxml are fully separated from logic.

Example:
DashboardController.java only handles UI updates, not DB logic:
public void loadDashboardStats() {
    CampaignDAO dao = new CampaignDAO();

    totalCampaignsLabel.setText(String.valueOf(dao.getTotalCampaigns()));
    activeCampaignsLabel.setText(String.valueOf(dao.getActiveCampaigns()));
    totalFundsLabel.setText("‚Çπ" + dao.getTotalFundsRaised());
}
Controllers stay small and focused ‚Üí higher readability and testing ease.


3. Reusable Database Connection Utility
You created a single connection provider:
public class DBConnect {
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/crowdfund",
            "root",
            "password"
        );
    }
}
Using this across DAO classes prevents:
‚ùå repeated code
‚ùå multiple driver loads
‚úî centralized DB config


4. Input Validation & Error Handling
In CreateCampaignController.java:
if (titleField.getText().isEmpty() || goalField.getText().isEmpty()) {
    System.out.println("Please fill all fields.");
    return;
}
This ensures only valid campaigns are inserted.



üöÄ Innovation Examples
1. Live Dashboard Analytics
Dashboard labels update from SQL queries:
totalCampaignsLabel.setText(String.valueOf(dao.getTotalCampaigns()));
The values come from optimized SQL:
SELECT COUNT(*) FROM campaigns;
This makes dashboard dynamic, real-time, and data-driven.

2. Smart SQL Schema With Future Support

Your .sql table includes fields that allow:
Tracking funds (raised)
Campaign status (is_active)
Safe auto-increment IDs
CREATE TABLE campaigns (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200),
    goal DOUBLE,
    raised DOUBLE DEFAULT 0,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE
);
This design makes it easy to add future features like:
‚ú® donors table
‚ú® user roles
‚ú® transaction logs

3. Scalable DAO Pattern
Adding a new feature (e.g., ‚ÄúTop Campaigns‚Äù) only requires:
A new method in CampaignDAO
A new label in dashboard.fxml
A controller update
This low dependency design shows strong modularity.



4. Consistent & Professional Java Coding Standards
Across all files you use:
camelCase for variables ‚Üí totalFundsLabel
PascalCase for classes ‚Üí CampaignDAO
Try-with-resources
No unnecessary static state
Avoiding business logic inside UI classes
These choices make the code look like a real production-level project.
